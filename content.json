{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/09/30/hello-world/"},{"title":"js用法细节总结","text":"[toc] 全局变量 &nbsp; 全局变量 语法1 不加var：&emsp;&emsp;&emsp;&emsp;test = 5; 语法2 加window：&emsp;&emsp;&emsp;&emsp;window.test = 5; BOM基础打开、关闭窗口 语法 参数说明 说明 window.open(‘url’,参数二选填); 参数一：url可填网址，也可填文件，用于打开新窗口参数二可填：_blank - URL加载到一个新的窗口(默认)_parent - URL加载到父框架_self - URL替换当前页面 open有返回值，返回新打开的window对象 window.close(); &nbsp; 关闭当前窗口 window对象.document.write(‘内容’) 可写内容，也可放入有内容的变量 先清空原页面，再写入新的东西 常用属性 语法 说明 window.navigator.userAgent 返回用户浏览器版本、操作系统等信息 window.location 返回该网页的html文件路径，还可以通过赋值的方式在当前窗口切换网页url window.location代码示例： 1234&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;aaa&quot; onclick=&quot;window.location='http://www.zhinengshe.com/';&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;bbb&quot; onclick=&quot;alert(window.location);&quot; /&gt;&lt;/body&gt; 尺寸及坐标可视区尺寸： 会随用户调整浏览器窗口大小而改变| 属性语法 | 说明 || ————————————- | ———— || document.documentElement.clientWidth | 可视区的宽度 || document.documentElement.clientHeight | 可视区的高度 | 滚动距离： 可视区上边界到网页头上边界的距离| 属性语法 | 说明 || ———————————- | ———————————————- || document.body.scrollTop | 旧版谷歌浏览器写法 || document.documentElement.scrollTop | 其他浏览器写法，新版谷歌也支持，现在写这个就行 | 滚动距离兼容性写法： 1var scrollTop=document.documentElement.scrollTop||document.body.scrollTop; 可视区和滚动距离图解： 常用的方法和事件系统对话框：| 方法语法 | 作用 | 说明 || ———————————————————- | ———- | ———————————- || alert(“内容”) | 警告框 | 没有返回值 || confirm(“提问的内容”) | Y/N选择框 | 返回ture/false || prompt(‘输入框的输入提示’,’输入框内的默认文字’) / prompt() | 文字输入框 | 返回输入的字符串，两个参数都为选填 | window对象常用事件： 事件名称 说明 onload 页面加载 onscroll 页面滚动时 onresize 页面大小调整时 函数调用时带括号和不带括号的区别代码示例： 1234567function countBodyChildren(){ var body_element = document.getElementsByTagName(&quot;body&quot;)[0]; alert(body_element.childNodes.length);}window.onload = countBodyChildren; // 页面加载完成执行//window.onload = countBodyChildren(); // 代码直接执行 区分 区别 简而言之 带括号 函数只要是要调用它进行执行的，都必须加括号。此时，函数实际上等于函数的返回值或者执行效果，当然，有些没有返回值，但已经执行了函数体内的行为，就是说，加括号的，就代表将会执行函数体代码。 带括号表示要立即执行的函数 不带括号 不加括号的，都是把函数名称作为函数的指针，一个函数的名称就是这个函数的指针，此时不是得到函数的结果，因为不会运行函数体代码。它只是传递了函数体所在的地址位置，在需要的时候好找到函数体去执行。 相当于函数的指针，传递了函数体的位置 事件直接等于函数仍然要写上function，不能直接等于 123456789function setStyle(name, value) { oDiv1.style[name] = value; } aInput[0].onclick = function (){ setStyle('width', '400px'); }; this用法this简单理解this指当前发生事件的对象，且当前的方法属于谁，this就指向谁（即谁调用指向谁） 例： 123456789101112&lt;script&gt;var arr=[1,2,3,4];arr.a=12;arr.show=function (){ alert(this.a);};arr.show();&lt;/script&gt; this指向当前发生事件的元素的用法this：当前发生事件的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #div1 .active {background:yellow;} #div1 div {width:200px; height:200px; background:#CCC; border:1px solid #999; display:none;} &lt;/style&gt; &lt;script&gt; window.onload = function(){ var oDiv1 = document.getElementById('div1'); var aInput = document.getElementsByTagName('input'); var aDiv = oDiv1.getElementsByTagName('div'); for(var i=0;i&lt;aInput.length;i++){ aInput[i].index = i; aInput[i].onclick = function(){ for(var i=0;i&lt;aInput.length;i++){ aInput[i].className = ''; aDiv[i].style.display = 'none'; } //this指向 aInput[i] //this：当前发生事件的元素 this.className = 'active'; aDiv[this.index].style.display = 'block'; }; } }; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;input class=&quot;active&quot; type=&quot;button&quot; value=&quot;教育&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;培训&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;招生&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;出国&quot; /&gt; &lt;div style=&quot;display:block;&quot;&gt;1111&lt;/div&gt; &lt;div&gt;2222&lt;/div&gt; &lt;div&gt;333&lt;/div&gt; &lt;div&gt;4444&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 改变this的指向call的使用call能通过传入参数的方式，改变函数的this指向 call语法：| call语法 | 备注 || ——————————— | ———————————————————— || 函数名.call(参数一，参数二，…); | 参数一：函数所要改变的this指向；参数二（选填）：函数传入的第一个参数，后面参数三、四以此类推 | 例子一：改变函数this指向代码实例： 123456789&lt;script&gt;function show(){ alert(this);}//show();show.call(12); //12&lt;/script&gt; 例子二：改变函数this指向并传入参数代码实例： 123456789&lt;script&gt;function show(a, b){ alert('this是：'+this+'\\na是：'+a+'\\nb是：'+b);}//show(12, 5);show.call('abc', 12, 5);&lt;/script&gt; apply的使用apply也能和call一样通过传入参数的方式，改变函数的this指向，但第二个参数是数组的形式 apply语法：| call语法 | 备注 || —————————– | ———————————————————— || 函数名.apply(参数一，[数组]); | 参数一：函数所要改变的this指向；参数二（选填）：以数组形式，将传入数组中的元素依次取出, 传递给形参 | 例子一：改变函数this指向代码实例： 123456789&lt;script&gt;var obj = {&quot;name&quot;: &quot;lnj2&quot;};function test() { console.log(this);}window.test.apply(obj);&lt;/script&gt; 例子二：改变函数this指向并传入数组代码实例： 12345678910&lt;script&gt;var obj = {&quot;name&quot;: &quot;lnj2&quot;};function sum(a, b) { console.log(this); console.log(a + b); //8}window.sum.apply(obj, [3, 5]);&lt;/script&gt; 引用的问题理解： JS的引用可以理解为浅拷贝 深拷贝和浅拷贝简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。 浅拷贝例子： 123456789&lt;script&gt;var arr1=[1,2,3];var arr2=arr1;arr2.push(4);alert(arr1); //1,2,3,4alert(arr2); //1,2,3,4&lt;/script&gt; 原因： arr1和arr2指向了同一个地址，所以修改arr2的同时arr1也收到了影响，这就是所谓的浅拷贝 问题解决： 可以在内存中先开辟新的空间，再把arr1的值通过遍历的方式赋值给arr2，代码如下深拷贝例子 深拷贝例子： 1234567891011121314&lt;script&gt;var arr1=[1,2,3];var arr2=[];for(var i=0;i&lt;arr1.length;i++){ arr2.push(arr1[i]);}arr2.push(4);alert(arr1); //1,2,3alert(arr2); //1,2,3,4&lt;/script&gt; 元素的true和false真(true)： 非零数字、非空字符串、非空对象假(false)：数字零、空字符串、空对象、undefined 123456789101112&lt;script&gt;var a;if(a){ alert('真的');}else{ alert('假的');}&lt;/script&gt; json的用法json类似于java的集合，可以存储不同类型的数据，且采用键值对的方式 12345678910&lt;script&gt;/*var a=12;var b=5;var c='abc';*/var json={a: 12, b: 5, c: 'abc'};json.b++;alert(json.b);&lt;/script&gt; json的语法： 1var 名称 = {...........}; 注意：json不是数组，没有length()属性 json的遍历方式：使用for in，当然数组也可以用for in 1234for(var i in json){ alert('第'+i+'个东西：'+json[i]);} json中this的指向：指向json对象 123456789101112131415161718&lt;script&gt;var json={ name: 'blue', qq: '258248832', showName: function () { alert('我的名字叫：'+this.name); }, showQQ: function () { alert('我的QQ号是：'+this.qq); }};json.showName();json.showQQ();&lt;/script&gt; 数组操作头尾添加元素push(元素)： 从尾部添加unshift(元素)：从头部添加 头尾删除元素pop()：从尾部弹出shift()：从头部弹出 中间插入、删除、替换元素(splice函数) 语法 参数解释 作用 splice(起点，长度) 起点：开始删除的元素下标；长度：要删除的元素个数 删除 splice(起点，0，新元素1，新元素2…) 从指定位置处插入新元素 从中间插入 splice(起点，长度，新元素1，新元素2…) 先删除指定位置个数的元素，在从该位置插入新元素 替换 数组连接数组a.concat(b)&emsp;&emsp;&emsp;&emsp;//将数组b接到数组a的尾部 数组排序1.纯字母字符串排序(a-z)直接使用sort()函数即可 12var arr=['float', 'width', 'alpha', 'zoom', 'left'];arr.sort(); 2.数字排序（小-大）需要使用排序函数 1234567var arr=[12, 8, 99, 19, 112];arr.sort(function (n1, n2){ return n1-n2;});alert(arr); 数组按分隔符分割join(分隔符)&emsp;&emsp;&emsp;&emsp;//用分隔符，组合数组元素，生成字符串 12var arr=[1,2,3,4];alert(arr.join('- -p')); 数组截取（slice）作用： 截取数组指定下标区间的内容，并把内容放到一个新数组，返回这个新数组 语法 作用 数组.slice(); 什么参数都不传, 会将数组中的元素放到一个新的数组中原样返回 数组.slice(参数一); 返回一个，从参数一下标开始截取，截取到末尾的新数组 数组.slice(参数二, 参数二); 返回一个，从参数一下标开始截取，截取到参数二下标，但不包括参数二下标的新数组 123456var arr2 = [1, 3, 5, 7, 9];var res2 = arr2.slice(); // 如果slice方法什么参数都没有传递, 会将数组中的元素放到一个新的数组中原样返回var res2 = arr2.slice(2); //从参数一下标开始截取，截取到末尾；输出579var res2 = arr2.slice(2, 4); //从参数一下标开始截取，截取到参数二下标，但不包括参数二下标console.log(res2); 真数组和伪数组的相互转换真数组转伪数组 语法 过程理解 [].push.apply(伪数组, 真数组); 1. 通过[].push找到数组中的push方法2. 通过apply(伪数组)将找到的push方法内部的this指向修改为伪数组3. 将传入的真数组中的元素依次取出, 传递给伪数组 代码示例： 12345var arr = [1, 3, 5, 7, 9];var obj = {};[].push.apply(obj, arr); //真数组转伪数组console.log(obj); 伪数组转真数组实现方式一：push+apply （但不兼容IE8及低版本浏览器） 语法 过程理解 [].push.apply(真数组, 伪数组); 1. 通过[].push找到数组中的push方法2. 通过apply(真数组)将找到的push方法内部的this指向修改为真数组3. 将传入的伪数组中的元素依次取出, 传递给真数组 代码示例： 1234var obj = {0:&quot;lnj&quot;, 1:&quot;33&quot;, length: 2};var arr = []; // 真数组[].push.apply(arr, obj); //IE8会出问题，不推荐，推荐用下面那个console.log(arr); 实现方式二：slice+call （兼容性写法，推荐使用） 语法 过程理解 [].slice.call(伪数组); 1. 通过[].slice找到数组中的slice方法2. 通过call(伪数组)将找到的slice方法内部的this指向修改为伪数组3. 对伪数组执行slice()函数，最后返回一个真数组 代码示例： 1234var obj = {0:&quot;lnj&quot;, 1:&quot;33&quot;, length: 2};var arr = [].slice.call(obj); //伪数组转真数组console.log(arr); 不定参arguments用法arguments是参数数组，表示参数的个数可变 123456789101112function sum(){ var result=0; for(var i=0;i&lt;arguments.length;i++) { result+=arguments[i]; } return result;}alert(sum(12, 6, 8, 6, 8, 6, 8, 6, 8, 6, 8, 6, 8, 6, 8, 6, 8, 6, 8, 6, 8, 6, 8, 6, 8)); 获取并设置非行间样式方法1. 获取：封装好了getStyle(obj, name)函数，且同时兼容IE,Chrom,FF 1234567891011121314151617181920&lt;script&gt;function getStyle(obj, name){ if(obj.currentStyle) { return obj.currentStyle[name]; //IE8及IE8以下写法 } else { return getComputedStyle(obj, false)[name]; //其他浏览器写法 }}window.onload=function (){ var oDiv=document.getElementById('div1'); alert(getStyle(oDiv, 'backgroundColor'));};&lt;/script&gt; 2. 获取/设置：封装好了css(obj, name, value)函数，两个参数时为获取样式，三参时为设置样式 ！仅限单一样式：width、height、position等，复合样式：background、border等无效 12345678910111213141516171819202122&lt;script&gt;function css(obj, name, value){ if(arguments.length==2) //获取 { return obj.style[name]; } else { obj.style[name]=value; }}window.onload=function (){ var oDiv=document.getElementById('div1'); // alert(css(oDiv, 'width')); css(oDiv, 'background', 'green');};&lt;/script&gt; 字符串操作字符串下标1. js字符串跟数组一样，可以用下标取元素： 123var str='abcdef';alert(str[0]); 2. 还可以用charAt()函数，取对应位置元素 123var str='abcdef';alert(str.charAt(0)); 字符串搜索search 语法 作用 字符串.search(‘子字符串/正则表达式’); 找到并且返回字符串出现的位置，如果没找到-1。能分辨大小写 12345&lt;script&gt;var str='abcdef';alert(str.search('cde')); //找到并且返回字符串出现的位置，如果没找到-1&lt;/script&gt; indexOf &nbsp; indexOf 语法 字符串.indexOf(子字符串,fromindex); 参数 参数一：必需。规定需检索的字符串值。参数二：选填。不填： 表示字符串从头开始检索。 填入整数： 表示从字符串 指定位置开始检索。 作用 可返回某个指定的字符串值在字符串中首次出现的位置。找到了会返回对应的字符串位置；没找到返回-1。能分辨大小写 12345678&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;Hello world!&quot;document.write(str.indexOf(&quot;Hello&quot;) + &quot;&lt;br /&gt;&quot;) //返回0document.write(str.indexOf(&quot;World&quot;) + &quot;&lt;br /&gt;&quot;) //返回-1document.write(str.indexOf(&quot;world&quot;)) //返回6&lt;/script&gt; 字符串分割 语法 作用 字符串.split(‘分隔符’); 用于把一个字符串分割成字符串数组 123456&lt;script&gt;var str='abc 123 ert';var arr=str.split(' ');alert(arr);&lt;/script&gt; 字符串去掉头尾空格 语法 作用 字符串.trim(); 去除字符串的头尾空格 1234&lt;script&gt;var str = &quot; Runoob &quot;;alert(str.trim()); //输出结果：Runoob&lt;/script&gt; 字符串替换 &nbsp; replace 语法 字符串.replace(regexp/substr,replacement); 参数 参数一：填入要匹配的字符串或正则表达式参数二：填入把匹配出的字符串替换成的字符串 作用 用一些字符替换另一些字符，或用一些字符替换一个或多个与正则表达式匹配的子串。 代码示例： 1234&lt;script&gt;var str = &quot; a b c &quot;;str.replace(/^\\s+|\\s+$/g, &quot;&quot;); //把头尾空格用空字符串代替，起到trim()的作用&lt;/script&gt; 忽略大小写比较字符串思路：js是一种区分大小写的语言，我们可以先转换成统一格式，再进行比较| 语法 | 作用 || ——————– | —————— || 字符串.toUpperCase() | 把字符串转换成大写 || 字符串.toLowerCase() | 把字符串转换成小写 | 字符串转数字注意字符串中既有数字又有其他内容的情况 1234parseInt(&quot;1234blue&quot;); //returns 1234 parseInt(&quot;0xA&quot;); //returns 10 parseInt(&quot;22.5&quot;); //returns 22 parseInt(&quot;blue&quot;); //returns NaN Date对象获取时间1. 获取系统时间（时，分，秒） 12345var oDate=new Date();alert(oDate.getHours()); //时alert(oDate.getMinutes()); //分alert(oDate.getSeconds()); //秒 2. 获取系统日期（年，月，日）月份特殊从0开始，故+1； 星期也从0开始，表示周日 123456var oDate=new Date();alert(oDate.getFullYear()); //年alert(oDate.getMonth()+1); //月（注意+1）alert(oDate.getDate()); //日alert(oDate.getDay()); //星期（0开始，表示周日） 设置时间123456var oDate=new Date();oDate.setDate(1); //设置日oDate.setHours(2); //设置时oDate.setMinutes(3)); //设置分oDate.setSeconds(4)); //设置秒 子节点注意事项获取子节点（都是只算第一层，孙子不算） 1.childNodeschildNodes.length&emsp;&emsp;&emsp;&emsp;会算上文本节点 12345678910111213&lt;script&gt;window.onload=function (){ var oUl=document.getElementById('ul1'); alert(oUl.childNodes.length); //此处返回的值为5（两元素节点。三文本节点） };&lt;/script&gt;&lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; childNodes.nodeType属性&emsp;&emsp;&emsp;&emsp;可以过滤文本节点，留下元素节点| 节点类型 | 返回值 || ——– | ———– || 文本节点 | nodeType==3 || 元素节点 | nodeType==1 | 1234567891011121314151617181920212223242526272829303132&lt;script&gt;window.onload=function (){ var oUl=document.getElementById('ul1'); for(var i=0;i&lt;oUl.childNodes.length;i++) { //nodeType==3 -&gt; 文本节点 //nodeType==1 -&gt; 元素节点 //alert(oUl.childNodes[i].nodeType); if(oUl.childNodes[i].nodeType==1) { oUl.childNodes[i].style.background='red'; } }};&lt;/script&gt;--------------------------------------------------&lt;body&gt;&lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;aaaabbbbfafafsdfasd 文本节点&lt;span&gt;qwerqwre 元素节点&lt;/span&gt;&lt;/body&gt; 2.childrenchildren.length&emsp;&emsp;&emsp;&emsp;直接返回元素节点个数 1234567891011121314151617181920212223242526&lt;script&gt;window.onload=function (){ var oUl=document.getElementById('ul1'); alert(oUl.children.length); for(var i=0;i&lt;oUl.children.length;i++) { oUl.children[i].style.background='red'; }};&lt;/script&gt;------------------------------------------------&lt;body&gt;&lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;aaaabbbbfafafsdfasd 文本节点&lt;span&gt;qwerqwre 元素节点&lt;/span&gt;&lt;/body&gt; 3.firstChild 和 firstElementChildIE6-8 用firstChild 12 //IE6-8oUl.firstChild.style.background='red'; 高版本浏览器 用firstElementChild 12 //高级浏览器oUl.firstElementChild.style.background='red'; 兼容性写法： 12345678if(oUl.firstElementChild){ oUl.firstElementChild.style.background='red';}else{ oUl.firstChild.style.background='red';} 创建、倒序插入、删除、克隆元素创建元素 步骤 语法 作用 1 createElement(标签名) 创建一个节点 2 appendChild(节点) 追加一个节点（1.先把元素从原有父级上删除 2.添加到新的父级） 父级.appendChild(子节点); 1234 var oLi=document.createElement('li'); //父级.appendChild(子节点);oUl.appendChild(oLi); 倒序插入元素 语法 作用 insertBefore(节点, 原有节点) 在已有元素前插入 父级.insertBefore(子节点, 原有节点); 12345678910111213141516171819202122232425262728293031323334&lt;script&gt;window.onload=function (){ var oBtn=document.getElementById('btn1'); var oUl=document.getElementById('ul1'); var oTxt=document.getElementById('txt1'); oBtn.onclick=function () { var oLi=document.createElement('li'); var aLi=oUl.getElementsByTagName('li'); oLi.innerHTML=oTxt.value; //父级.appendChild(子节点); //oUl.appendChild(oLi); if(aLi.length&gt;0) { oUl.insertBefore(oLi, aLi[0]); } else { oUl.appendChild(oLi); } };};&lt;/script&gt;--------------------------------------------------&lt;body&gt;&lt;input id=&quot;txt1&quot; type=&quot;text&quot;/&gt;&lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;创建li&quot;/&gt;&lt;ul id=&quot;ul1&quot;&gt;&lt;/ul&gt;&lt;/body&gt; 删除元素 语法 作用 removeChild(节点) 删除一个节点 父级.removeChild(子节点) 12345678910111213141516171819202122232425&lt;script&gt;window.onload=function (){ var aA=document.getElementsByTagName('a'); var oUl=document.getElementById('ul1'); for(var i=0;i&lt;aA.length;i++) { aA[i].onclick=function () { //父级.removeChild(子节点) oUl.removeChild(this.parentNode); }; }};&lt;/script&gt;-------------------------------------------&lt;body&gt;&lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;asfasd &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/li&gt; &lt;li&gt;5645 &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/li&gt; &lt;li&gt;ghdfjgj &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/li&gt; &lt;li&gt;mvbnmvnb &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 克隆（拷贝）元素 &nbsp; cloneNode() 语法 node.cloneNode(boolean); 参数 true：它还将递归复制当前节点的所有子孙节点false：它只复制当前节点 代码示例： 1234567891011121314151617181920&lt;body&gt;&lt;ul id=&quot;myList1&quot;&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Tea&lt;/li&gt;&lt;/ul&gt;&lt;ul id=&quot;myList2&quot;&gt;&lt;li&gt;Water&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;&lt;p id=&quot;demo&quot;&gt;单击按钮将项目从一个列表复制到另一个列表中&lt;/p&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;&lt;script&gt;function myFunction(){ var itm=document.getElementById(&quot;myList2&quot;).lastChild; var cln=itm.cloneNode(true); //节点以及其内容都被拷贝 //var cln=itm.cloneNode(false); //只有一个空的li元素将被克隆 document.getElementById(&quot;myList1&quot;).appendChild(cln);}&lt;/script&gt;&lt;/body&gt; 文档碎片文档碎片可以提高DOM操作性能(理论上)，但在高版本浏览器性能区别不大 1234567891011121314151617181920&lt;script&gt;window.onload=function (){ var oUl=document.getElementById('ul1'); var oFrag=document.createDocumentFragment(); for(var i=0;i&lt;10000;i++) { var oLi=document.createElement('li'); oFrag.appendChild(oLi); } oUl.appendChild(oFrag);};&lt;/script&gt;------------------------------------------------------&lt;body&gt;&lt;ul id=&quot;ul1&quot;&gt;&lt;/ul&gt;&lt;/body&gt; 表格table表格专用属性：tBodies、tHead、tFoot、rows、cells 12345678910111213141516171819202122232425262728293031323334&lt;script&gt;window.onload=function (){ var oTab=document.getElementById('tab1'); //alert(oTab.getElementsByTagName('tbody')[0].getElementsByTagName('tr')[1].getElementsByTagName('td')[1].innerHTML); alert(oTab.tBodies[0].rows[1].cells[1].innerHTML);};&lt;/script&gt;-------------------------------------------------&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;tab1&quot; border=&quot;1&quot; width=&quot;500&quot;&gt; &lt;thead&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;Blue&lt;/td&gt; &lt;td&gt;27&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; Math对象 常用方法 作用 abs(x) 返回数的绝对值 ceil(x) 对数进行上舍入 floor(x) 对数进行下舍入 max(x,y) 返回 x 和 y 中的最高值 min(x,y) 返回 x 和 y 中的最低值 random() 返回 0 ~ 1 之间的随机数 round(x) 把数四舍五入为最接近的整数 任意属性运动框架（且避免offset的bug）普通运动框架(单个属性运动)1234567891011121314151617181920212223242526272829303132333435function getStyle(obj, name) { if (obj.currentStyle) { return obj.currentStyle[name]; } else { return getComputedStyle(obj, false)[name]; } }function startMove(obj, attr, iTarget) { clearInterval(obj.timer); obj.timer = setInterval(function () { var cur = 0; if (attr == 'opacity') { cur = Math.round(parseFloat(getStyle(obj, attr)) * 100); } else { cur = parseInt(getStyle(obj, attr)); } obj.speed = (iTarget - cur) / 6; obj.speed = obj.speed &gt; 0 ? Math.ceil(obj.speed) : Math.floor(obj.speed); if (iTarget != cur) { if (attr == 'opacity') { obj.style[attr] = (cur + obj.speed) / 100; } else { obj.style[attr] = cur + obj.speed + 'px'; } } }, 30);} 链式运动框架（多个属性分阶段运动）1234567891011121314151617181920212223242526272829303132333435363738function getStyle(obj, name) { if (obj.currentStyle) { return obj.currentStyle[name]; } else { return getComputedStyle(obj, false)[name]; }}function startMove(obj, attr, iTarget, fnEnd) { clearInterval(obj.timer); obj.timer = setInterval(function () { var cur = 0; if (attr == 'opacity') { cur = Math.round(parseFloat(getStyle(obj, attr)) * 100); } else { cur = parseInt(getStyle(obj, attr)); } obj.speed = (iTarget - cur) / 6; obj.speed = obj.speed &gt; 0 ? Math.ceil(obj.speed) : Math.floor(obj.speed); if (iTarget != cur) { if (attr == 'opacity') { obj.style[attr] = (cur + obj.speed) / 100; } else { obj.style[attr] = cur + obj.speed + 'px'; } } else { clearInterval(obj.timer); if (fnEnd) fnEnd(); } }, 30);} 完美运动框架(多个属性同时运动，支持分阶段)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function getStyle(obj, name) { if (obj.currentStyle) { return obj.currentStyle[name]; } else { return getComputedStyle(obj, false)[name]; }}function startMove(obj, json, fnEnd) { clearInterval(obj.timer); obj.timer = setInterval(function () { var bStop = true; //假设：所有值都已经到了 for (var attr in json) { var cur = 0; if (attr == 'opacity') { cur = Math.round(parseFloat(getStyle(obj, attr)) * 100); } else { cur = parseInt(getStyle(obj, attr)); } obj.speed = (json[attr] - cur) / 6; obj.speed = obj.speed &gt; 0 ? Math.ceil(obj.speed) : Math.floor(obj.speed); if (json[attr] != cur) { bStop = false; //有一个属性没到都为false if (attr == 'opacity') { obj.style[attr] = (cur + obj.speed) / 100; } else { obj.style[attr] = cur + obj.speed + 'px'; } } } if (bStop) { clearInterval(obj.timer); //各个属性运动到位才关闭计时器 if (fnEnd) fnEnd(); } }, 30);} JS事件document理解document可理解成整个页面 如点击页面任何地方代码：（不用加body，用body则需要内容撑起来才能点到） 123456789&lt;script&gt;window.onload=function (){ document.onclick=function () { alert('a'); };};&lt;/script&gt; 且我们可以通过代码，看到document子节点名称 1alert(document.childNodes[1].tagName); //弹出内容为HTML event对象event对象的作用：用来获取事件的详细信息：鼠标位置、键盘按键 获取event对象（兼容性写法）123456789101112&lt;script&gt;window.onload=function (){ document.onclick=function (ev) { var oEvent=ev||event; //核心步骤 alert(oEvent.clientX+','+oEvent.clientY); };};&lt;/script&gt; 使用event对象取消事件冒泡(cancelBubble)事件冒泡：指子容器和父容器重叠时，点击子容器同时会触发父容器事件 123var oEvent = ev||event;oEvent.cancelBubble = true; event鼠标事件 鼠标事件 事件描述 onmousedown 摁下鼠标不放（左键、右键都行） onmouseup 弹起鼠标按键 onmousemove 鼠标移动 获取鼠标在页面的位置代码：（消除滚动条的影响:可视区与页面顶部的距离） 12345678910111213141516171819202122232425&lt;script&gt; function getPos(ev) { var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft; return { x: ev.clientX + scrollLeft, y: ev.clientY + scrollTop }; } document.onmousemove = function (ev) { var oEvent = ev || event; var oDiv1 = document.getElementById('div1'); var pos = getPos(oEvent); oDiv1.style.top = pos.y + 'px'; oDiv1.style.left = pos.x + 'px'; };&lt;/script&gt;-------------------------------&lt;body style=&quot;height:2000px;&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;/body&gt; event键盘事件 event.属性 作用 keyCode 返回用户按下键盘按键的ASCII码数值 ctrlKey 用户按下ctrl键 shiftKey 用户按下shift键 altKey 用户按下alt键 事件 作用 onkeydown 按下键盘按键 onkeyup 松开键盘按键 默认事件默认事件： 既不需要自己编写代码，浏览器自身所具备的一些功能 阻止默认事件语法： 1return false; 应用实例：阻止右键默认菜单，并使用自定义菜单 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;* {margin:0; padding:0; list-style:none;}#div1 {position:absolute; width:80px; background:#CCC; border:1px solid black; display:none;}&lt;/style&gt;------------------------------------------------&lt;script&gt; window.onload = function(){ var oDiv1 = document.getElementById('div1'); document.oncontextmenu = function(ev){ //oncontextmenu用户按下右键 var oEvent = ev||event; oDiv1.style.display = 'block'; oDiv1.style.left = oEvent.clientX + 'px'; oDiv1.style.top = oEvent.clientY + 'px'; return false; } document.onclick = function(){ oDiv1.style.display = 'none'; } };&lt;/script&gt;-------------------------------------------------&lt;body&gt;&lt;div id=&quot;div1&quot;&gt; &lt;ul&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;li&gt;ddd&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; 事件绑定和解除绑定 浏览器 事件绑定语法 解除绑定语法 备注 IE attachEvent(事件名称, 函数) detachEvent(事件名称, 函数) 事件带’on’ 其他浏览器 addEventListener(事件名称,函数, 捕获) removeEventListener(事件名称, 函数, 捕获) 事件不带’on’ ; 最后一个参数随便填，可以写false 能绑定同一事件，且不会相互覆盖，代码如下：**(兼容写法)** 123456789function myAddEvent(obj,ev,fn){ if(obj.attachEvent){ obj.attachEvent('on'+ev,fn); //IE写法 } else{ obj.addEventListener(ev,fn,false); //FF写法 }} 实例：按钮绑定两次onclick事件 12345678910111213141516171819202122232425262728&lt;script&gt; function myAddEvent(obj,ev,fn){ if(obj.attachEvent){ obj.attachEvent('on'+ev,fn); } else{ obj.addEventListener(ev,fn,false); } } window.onload = function(){ var oBtn1 = document.getElementById('btn1'); myAddEvent(oBtn1,'click',function(){ alert('a'); }); myAddEvent(oBtn1,'click',function(){ alert('b'); }); };&lt;/script&gt;-----------------------------------------------------------&lt;body&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&gt;&lt;/body&gt; 面向对象对象对象与类的联系 &nbsp; 对象 类 比喻 产品（成品） 产品的模子 命名规范 &nbsp; 类名首字母大写 对象的组成由属性和方法组成 其中：变量和属性，方法和函数对照表如下| &nbsp; | 对象的属性 | 对象的方法 | 变量 | 函数 || —— | —————- | ————– | ——————– | ——————– || 备注 | 属于一个对象 | 属于一个对象 | 自由的，不属于任何人 | 自由的，不属于任何人 || 语法 | 对象.属性名=xxx; | 对象.方法名(); | var 变量名=xxx; | 函数名(); | new关键字先看一段简单程序： 123456789&lt;script&gt;function show(){ alert(this);}show(); //windownew show(); //新new出来的对象&lt;/script&gt; 可见，调用函数时，不加new，this指向window；而加new后，this指向一个新创建出来的对象 即加new后，调用函数，系统会悄悄替咱们做： 12345var this=new.object();............return this; 原型(prototype)原型理解：| &nbsp; | 给对象加方法 | 给类加方法 || ——– | ———————————— | ————————————————— || 语法 | 对象名.方法名 = function(){ … } | 类名.prototype.方法名 = function(){ … } || 类比理解 | 类比行间样式，一次只能给单一元素加上 | 类比class，一次能给一组元素加上，该类中所有对象共享 | 原型限制： 只能加在类上，不能往对象上加 实例： 1234567891011121314151617181920&lt;script&gt;var arr1=new Array(12,55,34,78,676);var arr2=new Array(12,33, 1);Array.prototype.sum=function () //class，一次给一组元素加上，原型要往类上加，不能往对象上加//arr1.sum=function () //行间样式，一次给单一元素加上{ var result=0; for(var i=0;i&lt;this.length;i++) //此处的this指new关键字new出来的对象 { result+=this[i]; } return result;};alert(arr1.sum());alert(arr2.sum()); &lt;/script&gt; 原型的小缺陷： 无法限制覆盖 工厂模式什么是工厂模式：分为三大步：原料 -&gt; 加工 -&gt; 出厂，用构造函数创建一个类 普通模式代码： 12345678910111213141516171819202122232425262728&lt;script&gt;function createPerson(name, qq) //构造函数{ //原料 var obj=new Object(); //加工 obj.name=name; obj.qq=qq; obj.showName=function () { alert('我的名字叫：'+this.name); }; obj.showQQ=function () { alert('我的QQ号：'+this.qq); }; //出厂 return obj;}var obj=createPerson('blue', '258248832');var obj2=createPerson('张三', '45648979879');alert(obj.showName==obj2.showName);&lt;/script&gt; 存在问题： 没有new 函数重复定义 问题解决：引入new和原型到面向对象 混合方式构造对象（更为流行）理解： 采用构造函数 + 原型方式 构造对象 原则： 构造函数里加属性；原型里加方法 123456789101112131415161718192021222324252627&lt;script&gt;function CreatePerson(name, qq) //构造函数{ this.name=name; this.qq=qq;}CreatePerson.prototype.showName=function () //原型{ alert('我的名字叫：'+this.name);};CreatePerson.prototype.showQQ=function (){ alert('我的QQ号：'+this.qq);};var obj=new CreatePerson('blue', '258248832');var obj2=new CreatePerson('张三', '45648979879');/*obj.showName();obj.showQQ();obj2.showName();obj2.showQQ();*/alert(obj.showName==obj2.showName); //true&lt;/script&gt; json方式创建对象实例代码： 123456789101112131415161718&lt;script&gt;var json={ name: 'blue', qq: '258248832', showName: function () { alert('我的名字叫：'+this.name); }, showQQ: function () { alert('我的QQ号是：'+this.qq); }};json.showName();json.showQQ();&lt;/script&gt; 优点和缺点：优点： 与混合模式和工厂模式相比，较为简单缺点： 不适合多个对象的程序，只有整个程序里只有一个对象才适用 json方式实现命名空间命名空间： 公司里，把同一类方法，包在一起，方便查看 实例： 多个名字为getUser的方法，调用互不影响 1234567891011121314151617181920212223242526&lt;script&gt;var zns={};zns.common={};zns.fx={};zns.site={};zns.common.getUser=function (){ alert('a');};zns.fx.getUser=function (){ alert('b');};zns.site.getUser=function (){ alert('c');};zns.common.getUser();zns.fx.getUser();zns.site.getUser();&lt;/script&gt; 继承理解： 子类继承父类的属性和方法，加大代码复用程度，并且子类能够根据需要重写父类的方法，灵活变通 1. 引用方式继承（不推荐使用）12345678910111213141516171819&lt;script&gt; function A(){ this.abc = 12; } A.prototype.show = function(){ alert(this.abc); }; function B(){ A.call(this); } B.prototype = A.prototype; var obj = new B(); obj.show();&lt;/script&gt; 存在的问题： 由于引用方式是浅拷贝，修改子类方法时会影响到父类的方法 123456789101112131415161718192021222324252627282930&lt;script&gt;function A(){ this.abc=12;}A.prototype.show=function (){ alert(this.abc);};//继承Afunction B(){ //this-&gt;new B() A.call(this);}B.prototype=A.prototype;B.prototype.fn=function (){ alert('abc');};var objB=new B();var objA=new A();objA.fn(); //由于使用引用，导致本不应该有fn方法的父类有了fn方法&lt;/script&gt; 2. 不使用引用方式继承(使用这个)继承属性： 使用call实现继承方法： 使用prototype + 开辟新空间遍历 方式实现 代码示例： 123456789101112131415161718192021222324252627&lt;script&gt; function A() { this.abc = 12; } A.prototype.show = function () { alert(this.abc); }; function B() { A.call(this); } for (var i in A.prototype) { B.prototype[i] = A.prototype[i]; } B.prototype.fn = function () { //给B子类单独加方法 alert('abc'); }; var obj1 = new A(); var obj2 = new B(); obj1.fn(); //报错就对了 // obj2.fn();&lt;/script&gt; JS中本地对象、内置对象和宿主对象首先解释下宿主环境：一般宿主环境由外壳程序创建与维护，只要能提供js引擎执行的环境都可称之为外壳程序。如：web浏览器，一些桌面应用系统等。即由web浏览器或是这些桌面应用系统早就的环境即宿主环境。 对比表格：| 系统对象种类 | 定义 | 常见对象 | 特点 || ———————- | ———————————————————— | ———————————————————— | ————————— || 本地对象（非静态对象） | 独立于宿主环境的 ECMAScript 实现提供的对象 | Object、Function、Array、String、Boolean、Number、Date、RegExp、Error | 需要new进行实例化才能使用 || 内置对象（静态对象） | 由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现 | Global（仅概念上的，无法使用）、Math（最典型） | 不需要new进行实例化就能使用 || 宿主对象 | 由ECMAScript实现的宿主环境提供的对象 | 所有的BOM和DOM | 由浏览器提供的对象 |","link":"/2020/10/01/js%E7%94%A8%E6%B3%95%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93/"}],"tags":[],"categories":[]}